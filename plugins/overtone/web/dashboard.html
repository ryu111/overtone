<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Overtone Dashboard</title>
  <link rel="stylesheet" href="/static/styles/main.css">
  <script src="/js/pipeline.js"></script>
  <script src="/js/timeline.js"></script>
  <script>
    /* confetti.js åœ¨ Alpine è¼‰å…¥å¾Œæ‰åŸ·è¡Œï¼Œmain.css å·²æœ‰ confetti-fall keyframe */
    window.__ot_confetti_css_injected = true;
  </script>
  <script src="/js/confetti.js"></script>
  <script defer src="/static/vendor/alpine.min.js"></script>
</head>
<body x-data="dashboardApp()" x-init="init()">

  <!-- â”€â”€ Header â”€â”€ -->
  <header class="dashboard-header">
    <div class="logo">
      <span class="logo-icon">ğŸµ</span>
      Overtone
    </div>
    <button class="sidebar-toggle-btn"
            @click="sidebarOpen = !sidebarOpen"
            :title="sidebarOpen ? 'æ”¶åˆå´æ¬„' : 'å±•é–‹å´æ¬„'"
            x-text="sidebarOpen ? 'â€¹' : 'â€º'">
    </button>
    <div class="header-spacer"></div>
    <template x-if="activeSessionId">
      <span class="session-id-badge" x-text="activeSessionId ? activeSessionId.slice(0, 8) + '...' : ''"></span>
    </template>
    <template x-if="pipeline.workflowType">
      <span class="workflow-badge" x-text="getWorkflowLabel(pipeline.workflowType)"></span>
    </template>
    <div class="connection-dot" :class="connectionStatusClass"
         x-text="connectionStatusText"></div>
  </header>

  <!-- æ–·ç·šæ©«å¹…ï¼ˆé‡é€£ä¸­æˆ–æ–·ç·šæ™‚é¡¯ç¤ºï¼‰ -->
  <div class="disconnect-banner" x-show="!isConnected" x-cloak>
    <template x-if="_reconnectAttempts < 5 && _reconnectAttempts > 0">
      <span>SSE é€£ç·šä¸­æ–·ï¼Œè‡ªå‹•é‡é€£ä¸­ï¼ˆ<span x-text="_reconnectAttempts"></span>/5ï¼‰â€¦</span>
    </template>
    <template x-if="_reconnectAttempts >= 5">
      <span>é€£ç·šå·²ä¸­æ–·ï¼Œè«‹é‡æ–°æ•´ç†é é¢</span>
    </template>
    <template x-if="_reconnectAttempts === 0">
      <span>æ­£åœ¨å»ºç«‹é€£ç·šâ€¦</span>
    </template>
  </div>

  <!-- â”€â”€ Dashboard Layoutï¼ˆsidebar + main panelï¼‰ â”€â”€ -->
  <div class="dashboard-layout">

    <!-- â”€â”€ Sidebar â€” Session åˆ—è¡¨ â”€â”€ -->
    <aside class="sidebar" :class="{ closed: !sidebarOpen }">

      <!-- é€²è¡Œä¸­ -->
      <template x-if="liveSessions.length > 0">
        <div>
          <div class="session-group-header">
            <span>é€²è¡Œä¸­</span>
            <span class="session-group-count" x-text="liveSessions.length"></span>
          </div>
          <template x-for="session in liveSessions" :key="session.sessionId">
            <div class="session-item" :class="{ active: activeSessionId === session.sessionId }"
                 @click="selectSession(session.sessionId)">
              <button class="session-delete-btn" @click.stop="deleteSession(session.sessionId)">Ã—</button>
              <div class="session-item-top">
                <span class="session-live-dot"></span>
                <span class="session-item-workflow" x-text="getWorkflowLabel(session.workflowType)"></span>
              </div>
              <div class="session-item-sub" x-text="elapsedTime(session.createdAt)"></div>
              <template x-if="session.currentStage">
                <div class="session-item-stage" x-text="session.currentStage"></div>
              </template>
              <template x-if="session.progress?.total > 0">
                <div class="session-progress-bar">
                  <div class="session-progress-fill"
                       :style="`width:${Math.round(session.progress.completed/session.progress.total*100)}%`">
                  </div>
                </div>
              </template>
            </div>
          </template>
        </div>
      </template>

      <!-- å·²å®Œæˆ -->
      <template x-if="doneSessions.length > 0">
        <div>
          <div class="session-group-separator">
            <span x-text="`å·²å®Œæˆ (${doneSessions.length})`"></span>
          </div>
          <template x-for="session in doneSessions" :key="session.sessionId">
            <div class="session-item done" :class="{ active: activeSessionId === session.sessionId }"
                 @click="selectSession(session.sessionId)">
              <button class="session-delete-btn" @click.stop="deleteSession(session.sessionId)">Ã—</button>
              <div class="session-item-top">
                <span class="session-item-workflow" x-text="'âœ… ' + getWorkflowLabel(session.workflowType)"></span>
              </div>
              <div class="session-item-sub" x-text="elapsedTime(session.createdAt)"></div>
            </div>
          </template>
        </div>
      </template>

      <!-- å…¶ä»– (idle) -->
      <template x-if="idleSessions.length > 0">
        <div>
          <div class="session-group-separator" x-show="liveSessions.length > 0 || doneSessions.length > 0">
            <span x-text="`å…¶ä»– (${idleSessions.length})`"></span>
          </div>
          <template x-for="session in idleSessions" :key="session.sessionId">
            <div class="session-item done" :class="{ active: activeSessionId === session.sessionId }"
                 @click="selectSession(session.sessionId)">
              <button class="session-delete-btn" @click.stop="deleteSession(session.sessionId)">Ã—</button>
              <div class="session-item-top">
                <span class="session-item-workflow" x-text="getWorkflowLabel(session.workflowType) || 'ç„¡å·¥ä½œæµ'"></span>
              </div>
              <div class="session-item-sub" x-text="elapsedTime(session.createdAt)"></div>
            </div>
          </template>
        </div>
      </template>

      <!-- ç©ºç‹€æ…‹ -->
      <template x-if="sessions.length === 0">
        <div class="empty-state">å°šç„¡ session è¨˜éŒ„</div>
      </template>
    </aside>

    <!-- â”€â”€ Main Panel â”€â”€ -->
    <main class="main-panel" style="overflow-y: auto;">

      <!-- Tab Bar -->
      <nav class="tab-bar">
        <button class="tab-btn" :class="{ active: activeTab === 'pipeline' }" @click="activeTab = 'pipeline'">
          Pipeline
        </button>
        <button class="tab-btn" :class="{ active: activeTab === 'timeline' }" @click="activeTab = 'timeline'">
          Timeline
        </button>
        <button class="tab-btn" :class="{ active: activeTab === 'agents' }" @click="activeTab = 'agents'">
          Agents
        </button>
        <button class="tab-btn" :class="{ active: activeTab === 'history' }" @click="activeTab = 'history'">
          History
        </button>
      </nav>

      <!-- â•â•â• Pipeline Tab â•â•â• -->
      <div x-show="activeTab === 'pipeline'" class="tab-content" x-cloak>

        <!-- é€²åº¦åˆ— -->
        <template x-if="pipeline.workflowType">
          <div class="workflow-header" style="margin-bottom: var(--space-lg);">
            <div style="display:flex; align-items:center; gap: var(--space-sm); margin-bottom: var(--space-sm);">
              <h2 style="margin:0;" x-text="getWorkflowLabel(pipeline.workflowType)"></h2>
              <span style="color:var(--text-secondary); font-size:0.82rem;"
                    x-text="'(' + pipeline.workflowType + ')'"></span>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" :style="'width:' + progressPercent + '%'"></div>
            </div>
            <span class="progress-text" x-text="completedStageCount + '/' + totalStageCount + ' éšæ®µ'"></span>
          </div>
        </template>

        <!-- Pipeline Segments -->
        <div class="pipeline-wrapper">
          <template x-for="(segment, si) in pipelineSegments" :key="'seg-' + si">
            <div style="display:flex; align-items:center; flex: 1; min-width: 0;">

              <!-- é€£ç·šç®­é ­ï¼ˆéç¬¬ä¸€å€‹ segment å‰åŠ ï¼‰ -->
              <template x-if="si > 0">
                <div class="pipeline-connector">&#8594;</div>
              </template>

              <!-- ç·šæ€§ Stage -->
              <template x-if="segment.type === 'stage'">
                <div class="stage-card"
                     :class="getStageClass(segment.key)">
                  <div class="stage-icon" x-text="getStageEmoji(segment.key)"></div>
                  <div class="stage-label" x-text="getStageLabel(segment.key, segment.stage)"></div>
                  <div class="stage-status-icon" x-text="getStageIcon(segment.stage ? segment.stage.status : 'pending')"></div>
                </div>
              </template>

              <!-- ä¸¦è¡Œç¾¤çµ„ -->
              <template x-if="segment.type === 'parallel'">
                <div class="parallel-group">
                  <div class="parallel-group-label" x-text="segment.groupName"></div>
                  <div style="display:flex; align-items:center; gap: var(--space-xs);">
                    <template x-for="(ps, psi) in segment.stages" :key="'ps-' + psi">
                      <div style="display:flex; align-items:center;">
                        <template x-if="psi > 0">
                          <div style="width:16px; text-align:center; color:var(--text-muted); font-size:0.7rem;">+</div>
                        </template>
                        <div class="stage-card"
                             :class="getStageClass(ps.key)">
                          <div class="stage-icon" x-text="getStageEmoji(ps.key)"></div>
                          <div class="stage-label" x-text="getStageLabel(ps.key, ps.stage)"></div>
                          <div class="stage-status-icon" x-text="getStageIcon(ps.stage ? ps.stage.status : 'pending')"></div>
                        </div>
                      </div>
                    </template>
                  </div>
                </div>
              </template>

            </div>
          </template>
        </div>

        <!-- ç„¡å·¥ä½œæµæç¤º -->
        <template x-if="!pipeline.workflowType">
          <div class="empty-state">
            æ­¤ session å°šæœªå•Ÿå‹•å·¥ä½œæµã€‚ä½¿ç”¨ /ot:auto æˆ–æŒ‡å®š workflow é–‹å§‹ã€‚
          </div>
        </template>

        <!-- Stats -->
        <template x-if="pipeline.workflowType">
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-value" x-text="pipeline.failCount || 0"></div>
              <div class="stat-label">å¤±æ•—é‡è©¦</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" x-text="pipeline.rejectCount || 0"></div>
              <div class="stat-label">å¯©æŸ¥æ‹’çµ•</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" x-text="calcDuration(pipeline.createdAt)"></div>
              <div class="stat-label">ç¶“éæ™‚é–“</div>
            </div>
            <div class="stat-card">
              <div class="stat-value"
                   x-text="passatk.overall ? Math.round(passatk.overall.pass1Rate * 100) + '%' : 'â€”'"></div>
              <div class="stat-label">pass@1</div>
            </div>
            <div class="stat-card">
              <div class="stat-value"
                   x-text="passatk.overall ? Math.round(passatk.overall.pass3Rate * 100) + '%' : 'â€”'"></div>
              <div class="stat-label">pass@3</div>
            </div>
          </div>
        </template>

      </div>

      <!-- â•â•â• Timeline Tab â•â•â• -->
      <div x-show="activeTab === 'timeline'" class="tab-content" x-cloak>

        <!-- åˆ†é¡ç¯©é¸ + scroll lock -->
        <div class="filter-bar">
          <button class="filter-chip" :class="{ active: !timelineFilter }" @click="timelineFilter = ''">å…¨éƒ¨</button>
          <template x-for="cat in timelineCategories" :key="cat.key">
            <button class="filter-chip"
                    :class="{ active: timelineFilter === cat.key }"
                    @click="timelineFilter = cat.key"
                    x-text="cat.label">
            </button>
          </template>
          <button class="scroll-lock-btn"
                  :class="{ active: autoScrollTimeline }"
                  @click="autoScrollTimeline = !autoScrollTimeline"
                  x-text="autoScrollTimeline ? 'â†“ è·Ÿéš¨' : 'â¸ æš«åœ'">
          </button>
        </div>

        <!-- äº‹ä»¶åˆ—è¡¨ -->
        <div class="timeline-container">
          <div class="timeline-list" x-ref="timelineList" @scroll.passive="onTimelineScroll($event)">
            <template x-for="(event, idx) in filteredTimelineEvents" :key="event.ts + '-' + event.type + '-' + idx">
              <div class="timeline-event"
                   :class="window.OT.timeline.getCategoryClass(event.type)">
                <div class="event-time" x-text="window.OT.timeline.formatTimestamp(event.ts)"></div>
                <div class="event-label" x-text="event.label || event.type"></div>
                <div class="event-detail" x-text="formatEventDetail(event)"></div>
              </div>
            </template>
            <div class="empty-state" x-show="filteredTimelineEvents.length === 0">
              å°šç„¡äº‹ä»¶ç´€éŒ„
            </div>
          </div>
        </div>

      </div>

      <!-- â•â•â• Agents Tab â•â•â• -->
      <div x-show="activeTab === 'agents'" class="tab-content" x-cloak>

        <h3 style="margin-bottom: var(--space-md); color: var(--text-secondary);">Agent ç‹€æ…‹ç‡ˆè™Ÿ</h3>

        <div class="agent-grid">
          <template x-for="[name, info] in agentEntries" :key="name">
            <div class="agent-card"
                 :style="'border-left-color:' + getAgentColor(name)">
              <div class="agent-card-header">
                <div class="agent-card-name">
                  <div class="agent-dot size-md"
                       :class="[info.status === 'active' ? 'active' : 'standby', 'color-' + (getAgentColorName(name) || 'purple')]">
                  </div>
                  <span x-text="name"></span>
                </div>
                <span class="agent-model-badge" x-text="info.model || ''"></span>
              </div>
              <div class="agent-card-stage" x-text="info.currentStage ? info.currentStage : (info.status === 'active' ? 'åŸ·è¡Œä¸­' : 'å¾…æ©Ÿ')"></div>
              <template x-if="info.status === 'active' && info.startedAt">
                <div class="agent-card-duration" x-text="calcDuration(info.startedAt)"></div>
              </template>
            </div>
          </template>
        </div>

        <template x-if="agentEntries.length === 0">
          <div class="empty-state">å°šç„¡ agent è³‡æ–™</div>
        </template>

      </div>

      <!-- â•â•â• History Tabï¼ˆSessions åˆ—è¡¨å¡ç‰‡ï¼‰ â•â•â• -->
      <div x-show="activeTab === 'history'" class="tab-content" x-cloak>

        <h3 style="margin-bottom: var(--space-md); color: var(--text-secondary);">Session æ­·å²è¨˜éŒ„</h3>

        <template x-if="sessions.length === 0">
          <div class="empty-state">å°šç„¡ session è¨˜éŒ„</div>
        </template>

        <template x-for="session in sessions" :key="'h-' + session.sessionId">
          <div class="history-card" @click="selectSession(session.sessionId); activeTab = 'pipeline'">
            <div class="history-card-header">
              <div class="workflow-type-label"
                   x-text="session.workflowType ? getWorkflowLabel(session.workflowType) : 'ç„¡å·¥ä½œæµ'">
              </div>
              <span class="status-pill"
                    :class="session.status === 'completed' ? 'pass' : (session.status === 'active' ? 'active' : '')"
                    x-text="session.status === 'completed' ? 'å®Œæˆ' : (session.status === 'active' ? 'é€²è¡Œä¸­' : (session.status || 'â€”'))">
              </span>
            </div>
            <div class="history-card-stats">
              <span class="session-id-mono" x-text="session.sessionId.slice(0, 16) + '...'"></span>
              <span class="session-time" x-text="formatTime(session.createdAt)"></span>
            </div>
          </div>
        </template>

      </div>

    </main>
  </div>

  <style>
  [x-cloak] { display: none !important; }

  /* main-panel åœ¨ grid ä¸­ä½” col 2ï¼Œrow 2 èµ· */
  .main-panel {
    grid-column: 2;
    grid-row: 2 / -1;
    overflow-y: auto;
    min-height: 0;
  }

  /* tab-bar åœ¨ main-panel å…§ sticky */
  .main-panel .tab-bar {
    position: sticky;
    top: 0;
    z-index: 90;
    grid-column: unset;
  }

  /* tab-content æœ€å¤§å¯¬åº¦ */
  .tab-content {
    padding: var(--space-lg);
    max-width: 1400px;
  }
  </style>

  <script>
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     dashboardApp â€” Overtone SPA ä¸»ç‹€æ…‹
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  function dashboardApp() {
    return {
      // Session ç®¡ç†
      sessions: [],
      activeSessionId: null,

      // Pipeline è³‡æ–™
      pipeline: {
        stages: {},
        workflowType: '',
        parallelGroups: [],
        failCount: 0,
        rejectCount: 0,
        createdAt: null,
      },

      // Timeline è³‡æ–™
      timeline: { events: [] },
      timelineFilter: '',
      timelineCategories: [
        { key: 'workflow', label: 'å·¥ä½œæµ' },
        { key: 'stage',    label: 'éšæ®µ' },
        { key: 'agent',    label: 'ä»£ç†' },
        { key: 'loop',     label: 'å¾ªç’°' },
        { key: 'parallel', label: 'ä¸¦è¡Œ' },
        { key: 'handoff',  label: 'äº¤æ¥' },
        { key: 'error',    label: 'éŒ¯èª¤' },
        { key: 'session',  label: 'å·¥ä½œéšæ®µ' },
        { key: 'grader',   label: 'Grader' },
      ],

      // Agents
      agents: {},

      // Pass@k çµ±è¨ˆ
      passatk: { overall: null, stages: {} },

      // UI ç‹€æ…‹
      activeTab: 'pipeline',
      isConnected: false,
      confettiPlayed: false,
      autoScrollTimeline: true,
      sidebarOpen: window.innerWidth >= 1200,

      // SSE é€£ç·šç®¡ç†
      _sessionEventSource: null,
      _allEventSource: null,
      _reconnectAttempts: 0,
      _reconnectTimer: null,
      _disconnectDebounceTimer: null,

      // Registry éœæ…‹è³‡æ–™
      registry: { parallelGroupDefs: {}, workflows: {}, stages: {}, agents: {} },

      // â”€â”€ Computed â”€â”€

      get connectionStatusText() {
        if (this.isConnected) return 'å·²é€£ç·š';
        if (this._reconnectAttempts >= 5) return 'æ–·ç·š';
        if (this._reconnectAttempts > 0) return 'é‡é€£ä¸­ï¼ˆ' + this._reconnectAttempts + '/5ï¼‰';
        return 'é€£ç·šä¸­â€¦';
      },

      get connectionStatusClass() {
        if (this.isConnected) return 'online';
        if (this._reconnectAttempts >= 5) return 'failed';
        if (this._reconnectAttempts > 0) return 'reconnecting';
        return '';
      },

      get pipelineSegments() {
        if (!window.OT || !window.OT.pipeline) return [];
        const wf = this.pipeline.workflowType;
        const stages = this.pipeline.stages || {};
        const defs = this.registry.parallelGroupDefs || {};
        const wfGroups = {};
        for (const [k, v] of Object.entries(this.registry.workflows || {})) {
          wfGroups[k] = v.parallelGroups || [];
        }
        return window.OT.pipeline.buildPipelineSegments(stages, wf, defs, wfGroups);
      },

      get filteredTimelineEvents() {
        if (!this.timelineFilter) return this.timeline.events;
        return this.timeline.events.filter(e => {
          const colon = (e.type || '').indexOf(':');
          const prefix = colon !== -1 ? e.type.slice(0, colon) : e.type;
          return prefix === this.timelineFilter;
        });
      },

      get agentEntries() {
        return Object.entries(this.agents || {});
      },

      get completedStageCount() {
        return Object.values(this.pipeline.stages || {})
          .filter(s => s.status === 'completed' || s.status === 'done').length;
      },

      get totalStageCount() {
        return Object.keys(this.pipeline.stages || {}).length;
      },

      get progressPercent() {
        if (this.totalStageCount === 0) return 0;
        return Math.round(this.completedStageCount / this.totalStageCount * 100);
      },

      get liveSessions() {
        return this.sessions.filter(s => s.isActive);
      },

      get doneSessions() {
        return this.sessions.filter(s =>
          !s.isActive && s.progress?.total > 0 && s.progress.completed >= s.progress.total
        );
      },

      get idleSessions() {
        return this.sessions.filter(s =>
          !s.isActive && !(s.progress?.total > 0 && s.progress.completed >= s.progress.total)
        );
      },

      // â”€â”€ ç”Ÿå‘½é€±æœŸ â”€â”€

      async init() {
        await this.loadRegistry();
        await this.loadSessions();
        this.connectAllSSE();

        // è‡ªå‹•é¸æœ€æ–° active session
        if (this.sessions.length > 0) {
          const active = this.sessions.find(s => s.isActive);
          const target = active || this.sessions[0];
          if (target) {
            await this.selectSession(target.sessionId);
          }
        }
      },

      // â”€â”€ Registry è¼‰å…¥ â”€â”€

      async loadRegistry() {
        try {
          const r = await fetch('/api/registry');
          if (r.ok) {
            this.registry = await r.json();
          }
        } catch {
          // fallbackï¼šAPI ä¸å¯ç”¨æ™‚ä½¿ç”¨ç©º registry
        }
      },

      // â”€â”€ Sessions è¼‰å…¥ â”€â”€

      async loadSessions() {
        try {
          const r = await fetch('/api/sessions');
          if (r.ok) {
            this.sessions = await r.json();
          }
        } catch {
          // éœé»˜ï¼Œç”± SSE all è£œé€
        }
      },

      // â”€â”€ Session åˆ‡æ› â”€â”€

      async selectSession(id) {
        if (id === this.activeSessionId) return;

        // æ–·é–‹èˆŠ session SSE
        this.disconnectSessionSSE();

        // é‡è¨­ç‹€æ…‹
        this.activeSessionId = id;
        this.pipeline = { stages: {}, workflowType: '', parallelGroups: [], failCount: 0, rejectCount: 0, createdAt: null };
        this.timeline = { events: [] };
        this.agents = {};
        this.passatk = { overall: null, stages: {} };
        this.confettiPlayed = false;
        this.activeTab = 'pipeline';
        this.autoScrollTimeline = true;
        this._reconnectAttempts = 0;

        // è¼‰å…¥ REST åˆå§‹ç‹€æ…‹
        await Promise.all([
          this.fetchSessionState(id),
          this.fetchSessionTimeline(id),
          this.fetchPassatk(id),
        ]);

        // å»ºç«‹æ–° SSE é€£ç·š
        this.connectSessionSSE(id);
      },

      // â”€â”€ Session åˆªé™¤ â”€â”€

      async deleteSession(id) {
        await fetch(`/api/sessions/${id}`, { method: 'DELETE' });
        this.sessions = this.sessions.filter(s => s.sessionId !== id);
        if (this.activeSessionId === id) {
          this.activeSessionId = null;
          this.pipeline = { stages: {}, workflowType: '', parallelGroups: [], failCount: 0, rejectCount: 0, createdAt: null };
          this.timeline = { events: [] };
          this.agents = {};
          this.passatk = { overall: null, stages: {} };
          this.disconnectSessionSSE();
        }
      },

      // â”€â”€ è³‡æ–™è¼‰å…¥ â”€â”€

      async fetchSessionState(sessionId) {
        try {
          const r = await fetch('/api/sessions/' + sessionId);
          if (r.ok) {
            const data = await r.json();
            this.applyWorkflowState(data);
          }
        } catch {
          // éœé»˜ï¼ŒSSE è£œé€
        }
      },

      async fetchSessionTimeline(sessionId) {
        try {
          const r = await fetch('/api/sessions/' + sessionId + '/timeline');
          if (r.ok) {
            const events = await r.json();
            this.timeline = { events: events || [] };
          }
        } catch {
          // éœé»˜
        }
      },

      async fetchPassatk(sessionId) {
        try {
          const r = await fetch('/api/sessions/' + sessionId + '/passatk');
          if (r.ok) {
            const data = await r.json();
            this.passatk = data;
          }
        } catch {
          // éœé»˜
        }
      },

      // â”€â”€ SSE â€” å…¨å±€ï¼ˆsidebar æ›´æ–°ï¼‰ â”€â”€

      connectAllSSE() {
        if (this._allEventSource) {
          this._allEventSource.close();
        }

        const es = new EventSource('/sse/all');

        es.addEventListener('connected', () => {
          // sidebar SSE å·²é€£
        });

        es.addEventListener('workflow', () => {
          // æ”¶åˆ° workflow æ›´æ–°æ™‚é‡æ–°è¼‰å…¥ sessions åˆ—è¡¨
          this.loadSessions();
        });

        es.addEventListener('heartbeat', () => {
          // ä¿æŒé€£ç·š
        });

        es.onerror = () => {
          // sidebar SSE ä¸å½±éŸ¿é€£ç·šæŒ‡ç¤ºç‡ˆï¼Œéœé»˜é‡é€£
          if (this._allEventSource) {
            this._allEventSource.close();
            this._allEventSource = null;
          }
          setTimeout(() => this.connectAllSSE(), 5000);
        };

        this._allEventSource = es;
      },

      // â”€â”€ SSE â€” Session å°ˆå±¬ â”€â”€

      connectSessionSSE(sessionId) {
        this.disconnectSessionSSE();

        const es = new EventSource('/sse/' + sessionId);

        es.addEventListener('connected', () => {
          clearTimeout(this._disconnectDebounceTimer);
          this._disconnectDebounceTimer = null;
          this.isConnected = true;
          this._reconnectAttempts = 0;
        });

        es.addEventListener('workflow', (e) => {
          try {
            const data = JSON.parse(e.data);
            this.applyWorkflowState(data);
          } catch {
            // SSE è³‡æ–™æ ¼å¼ç•°å¸¸ï¼Œç•¥é
          }
        });

        es.addEventListener('timeline', (e) => {
          try {
            const event = JSON.parse(e.data);
            this.handleSSETimelineEvent(event);
          } catch {
            // SSE è³‡æ–™æ ¼å¼ç•°å¸¸ï¼Œç•¥é
          }
        });

        es.addEventListener('heartbeat', () => {
          clearTimeout(this._disconnectDebounceTimer);
          this._disconnectDebounceTimer = null;
          this.isConnected = true;
        });

        es.onerror = () => {
          // debounceï¼šçŸ­æš«æ–·ç·šï¼ˆé‡é€£ä¸­ï¼‰ä¸ç«‹åˆ»é¡¯ç¤ºã€Œé€£ç·šä¸­ã€ï¼Œ1 ç§’å¾Œä»æœªæ¢å¾©æ‰æ›´æ–°ç‹€æ…‹
          if (!this._disconnectDebounceTimer) {
            this._disconnectDebounceTimer = setTimeout(() => {
              this._disconnectDebounceTimer = null;
              this.isConnected = false;
            }, 1000);
          }
          if (this._sessionEventSource) {
            this._sessionEventSource.close();
            this._sessionEventSource = null;
          }
          this.scheduleReconnect(sessionId);
        };

        this._sessionEventSource = es;
      },

      disconnectSessionSSE() {
        clearTimeout(this._reconnectTimer);
        this._reconnectTimer = null;
        clearTimeout(this._disconnectDebounceTimer);
        this._disconnectDebounceTimer = null;
        if (this._sessionEventSource) {
          this._sessionEventSource.close();
          this._sessionEventSource = null;
        }
        this.isConnected = false;
      },

      scheduleReconnect(sessionId) {
        if (this._reconnectAttempts >= 5) return;
        const delay = Math.min(1000 * Math.pow(2, this._reconnectAttempts), 16000);
        this._reconnectAttempts++;
        this._reconnectTimer = setTimeout(() => {
          if (this.activeSessionId === sessionId) {
            this.connectSessionSSE(sessionId);
          }
        }, delay);
      },

      // â”€â”€ SSE äº‹ä»¶è™•ç† â”€â”€

      handleSSETimelineEvent(event) {
        this.timeline.events.push(event);

        // è§¸ç™¼ timeline slide-in å‹•ç•« + è‡ªå‹•è·Ÿéš¨ scroll
        if (this.activeTab === 'timeline') {
          this.$nextTick(() => {
            const el = this.$refs.timelineList;
            if (el) {
              window.OT.timeline.animateNewEvent(el, event);
              if (this.autoScrollTimeline) {
                el.scrollTop = el.scrollHeight;
              }
            }
          });
        }

        // æª¢æŸ¥ workflow å®Œæˆäº‹ä»¶
        const type = event.type || '';
        if (type === 'workflow:complete' || type.startsWith('workflow:complete')) {
          this.handleWorkflowComplete();
        }

        // æ›´æ–° pipeline stage ç‹€æ…‹
        if (type.startsWith('stage:')) {
          this.handleSSEStageEvent(type, event);
        }

        // æ›´æ–° agent ç‹€æ…‹
        if (type.startsWith('agent:')) {
          this.handleSSEAgentEvent(type, event);
        }
      },

      handleSSEStageEvent(type, event) {
        const stageKey = event.stage;
        if (!stageKey) return;
        if (!this.pipeline.stages[stageKey]) {
          this.pipeline.stages[stageKey] = { status: 'pending' };
        }
        if (type === 'stage:start') {
          this.pipeline.stages[stageKey].status = 'active';
          this.pipeline.stages[stageKey].startedAt = event.ts;
        } else if (type === 'stage:complete') {
          this.pipeline.stages[stageKey].status = 'completed';
          this.pipeline.stages[stageKey].completedAt = event.ts;
          this.pipeline.stages[stageKey].result = event.result;
        } else if (type === 'stage:fail') {
          this.pipeline.stages[stageKey].status = 'failed';
        }
      },

      handleSSEAgentEvent(type, event) {
        const agentName = event.agent;
        if (!agentName) return;
        if (!this.agents[agentName]) {
          const regInfo = (this.registry.agents || {})[agentName] || {};
          this.agents[agentName] = {
            status: 'standby',
            color: regInfo.color || '',
            model: regInfo.model || '',
            currentStage: null,
          };
        }
        if (type === 'agent:delegate') {
          this.agents[agentName].status = 'active';
          this.agents[agentName].currentStage = event.stage || null;
          this.agents[agentName].startedAt = event.ts;
        } else if (type === 'agent:complete') {
          this.agents[agentName].status = 'standby';
          this.agents[agentName].currentStage = null;
        }
      },

      handleWorkflowComplete() {
        // æ›´æ–° sidebar sessions ç‹€æ…‹
        this.loadSessions();

        // è§¸ç™¼ confettiï¼ˆåªæ’­ä¸€æ¬¡ï¼‰
        if (!this.confettiPlayed && window.OT && window.OT.confetti) {
          const fired = window.OT.confetti.fire({ played: this.confettiPlayed, count: 40 });
          if (fired) {
            this.confettiPlayed = true;
          }
        }
      },

      // â”€â”€ å¥—ç”¨ workflow stateï¼ˆREST + SSE workflow äº‹ä»¶å…±ç”¨ï¼‰ â”€â”€

      applyWorkflowState(data) {
        if (!data) return;

        this.pipeline = {
          stages: data.stages || {},
          workflowType: data.workflowType || '',
          parallelGroups: data.parallelGroups || [],
          failCount: data.failCount || 0,
          rejectCount: data.rejectCount || 0,
          createdAt: data.createdAt || null,
        };

        // å¾ activeAgents å»ºç«‹ agents map
        const activeAgents = data.activeAgents || {};
        for (const [name, info] of Object.entries(activeAgents)) {
          const regInfo = (this.registry.agents || {})[name] || {};
          this.agents[name] = {
            status: 'active',
            color: regInfo.color || '',
            model: regInfo.model || '',
            currentStage: info.stage || null,
            startedAt: info.startedAt || null,
          };
        }

        // ç¢ºä¿ registry agents ä¹Ÿåœ¨ map ä¸­ï¼ˆstandbyï¼‰
        for (const [name, info] of Object.entries(this.registry.agents || {})) {
          if (!this.agents[name]) {
            this.agents[name] = {
              status: 'standby',
              color: info.color || '',
              model: info.model || '',
              currentStage: null,
            };
          }
        }
      },

      // â”€â”€ è¼”åŠ©ï¼šPipeline â”€â”€

      getStageClass(stageKey) {
        if (!window.OT || !window.OT.pipeline) return 'pending';
        return window.OT.pipeline.getStageClass(stageKey, this.pipeline.stages);
      },

      getStageEmoji(stageKey) {
        const base = stageKey.split(':')[0];
        return (this.registry.stages || {})[base]?.emoji || '?';
      },

      getStageLabel(stageKey, stageData) {
        const base = stageKey.split(':')[0];
        const reg = (this.registry.stages || {})[base];
        if (!reg) return stageKey;
        if (base === 'TEST' && stageData) {
          if (stageData.mode === 'spec') return 'æ¸¬è©¦:è¦æ ¼';
          if (stageData.mode === 'verify') return 'æ¸¬è©¦:é©—è­‰';
        }
        return reg.label || stageKey;
      },

      getStageIcon(status) {
        if (!window.OT || !window.OT.pipeline) return '?';
        return window.OT.pipeline.getStageIcon(status);
      },

      getWorkflowLabel(workflowType) {
        if (!workflowType) return 'â€”';
        return (this.registry.workflows || {})[workflowType]?.label || workflowType;
      },

      // â”€â”€ è¼”åŠ©ï¼šAgents â”€â”€

      getAgentColor(name) {
        const info = (this.registry.agents || {})[name];
        if (!info || !info.color) return 'var(--text-muted)';
        return 'var(--color-' + info.color + ')';
      },

      getAgentColorName(name) {
        return (this.registry.agents || {})[name]?.color || 'purple';
      },

      // â”€â”€ è¼”åŠ©ï¼šTimeline scroll â”€â”€

      onTimelineScroll(e) {
        const el = e.target;
        // è·é›¢åº•éƒ¨ < 40px è¦–ç‚ºã€Œåœ¨åº•éƒ¨ã€â†’ è‡ªå‹•é‡æ–°é–å®š
        const atBottom = el.scrollHeight - el.scrollTop - el.clientHeight < 40;
        if (atBottom) {
          this.autoScrollTimeline = true;
        } else {
          this.autoScrollTimeline = false;
        }
      },

      // â”€â”€ è¼”åŠ©ï¼šæ™‚é–“ â”€â”€

      formatTime(iso) {
        if (!iso) return '';
        try {
          return new Date(iso).toLocaleString('zh-TW', {
            month: 'numeric',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            hour12: false,
          });
        } catch {
          return iso;
        }
      },

      elapsedTime(iso) {
        if (!iso) return '';
        const diff = Date.now() - new Date(iso).getTime();
        const m = Math.floor(diff / 60000);
        if (m < 60) return m + 'm å‰';
        const h = Math.floor(m / 60);
        if (h < 24) return h + 'h å‰';
        return Math.floor(h / 24) + 'd å‰';
      },

      calcDuration(iso) {
        if (!iso) return '-';
        const ms = Date.now() - new Date(iso).getTime();
        const m = Math.floor(ms / 60000);
        const s = Math.floor((ms % 60000) / 1000);
        if (m > 60) {
          const h = Math.floor(m / 60);
          return h + 'h ' + (m % 60) + 'm';
        }
        return m > 0 ? m + 'm ' + s + 's' : s + 's';
      },

      // â”€â”€ è¼”åŠ©ï¼šTimeline â”€â”€

      formatEventDetail(event) {
        const parts = [];
        if (event.agent) parts.push(event.agent);
        if (event.stage) parts.push(event.stage);
        if (event.workflowType) {
          const label = this.getWorkflowLabel(event.workflowType);
          parts.push(label !== event.workflowType ? label : event.workflowType);
        }
        if (event.iteration !== undefined) parts.push('ç¬¬ ' + event.iteration + ' æ¬¡');
        if (event.progress) parts.push(event.progress);
        if (event.reason) parts.push(event.reason);
        if (event.result) parts.push(event.result);
        if (event.duration) parts.push(event.duration);
        return parts.join(' Â· ');
      },

      // â”€â”€ ç”Ÿå‘½é€±æœŸæ¸…ç† â”€â”€

      destroy() {
        this.disconnectSessionSSE();
        if (this._allEventSource) {
          this._allEventSource.close();
          this._allEventSource = null;
        }
      },
    };
  }
  </script>

</body>
</html>
