<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Overtone â€” Session</title>
  <link rel="stylesheet" href="/static/main.css">
  <script defer
    src="https://cdn.jsdelivr.net/npm/alpinejs@3.14.8/dist/cdn.min.js"
    integrity="sha384-X9kJyAubVxnP0hcA+AMMs21U445qsnqhnUF8EBlEpP3a42Kh/JwWjlv2ZcvGfphb"
    crossorigin="anonymous"></script>
</head>
<body x-data="sessionState('{{SESSION_ID}}')">

  <!-- Header -->
  <header>
    <a href="/" class="logo">ğŸµ Overtone</a>
    <span class="session-id-header" x-text="sessionId.slice(0, 8) + '...'"></span>
    <div class="header-spacer"></div>
    <div class="connection-status" :class="connected ? 'online' : ''">
      <span x-text="connected ? 'å·²é€£ç·š' : 'é‡æ–°é€£ç·šä¸­...'"></span>
    </div>
  </header>

  <!-- Tab å°èˆª -->
  <nav class="tabs">
    <button @click="tab = 'overview'" :class="{ active: tab === 'overview' }">
      ğŸ“Š æ¦‚è¦½
    </button>
    <button @click="tab = 'timeline'" :class="{ active: tab === 'timeline' }">
      ğŸ“œ æ™‚é–“è»¸
    </button>
  </nav>

  <!-- â•â•â• Overview Tab â•â•â• -->
  <section x-show="tab === 'overview'" x-cloak class="tab-content">

    <!-- å·¥ä½œæµé¡å‹ + é€²åº¦ -->
    <div class="workflow-header">
      <h2>
        <span x-text="workflowLabel"></span>
        <span style="font-weight:normal; font-size:0.85rem; color:var(--text-secondary)"
              x-text="workflow.workflowType ? '(' + workflow.workflowType + ')' : ''"></span>
      </h2>
      <div class="progress-bar">
        <div class="progress-fill" :style="'width:' + progressPercent + '%'"></div>
      </div>
      <span class="progress-text" x-text="completedCount + '/' + totalCount + ' éšæ®µ'"></span>
    </div>

    <!-- Stage ç®¡ç·š -->
    <div class="pipeline">
      <template x-for="[key, stage] in stageEntries" :key="key">
        <div class="stage-card" :class="stage.status">
          <div class="stage-icon" x-text="getStageEmoji(key)"></div>
          <div class="stage-label" x-text="getStageLabel(key)"></div>
          <div class="stage-status">
            <span x-show="stage.status === 'completed' && stage.result === 'pass'">âœ…</span>
            <span x-show="stage.status === 'completed' && stage.result === 'fail'">âŒ</span>
            <span x-show="stage.status === 'completed' && stage.result === 'reject'">ğŸ”™</span>
            <span x-show="stage.status === 'active' || stage.status === 'in-progress'" class="pulse">â³</span>
            <span x-show="stage.status === 'pending'">â¬œ</span>
          </div>
        </div>
      </template>
    </div>

    <!-- Active Agents -->
    <div class="agents-section" x-show="activeAgentEntries.length > 0">
      <h3>ğŸ¤– åŸ·è¡Œä¸­çš„ä»£ç†</h3>
      <div class="agent-list">
        <template x-for="[name, info] in activeAgentEntries" :key="name">
          <div class="agent-card" :style="'border-left-color:' + getAgentColor(name)">
            <div class="agent-name" x-text="name"></div>
            <div class="agent-stage" x-text="info.stage"></div>
            <div class="agent-duration" x-text="calcDuration(info.startedAt)"></div>
          </div>
        </template>
      </div>
    </div>

    <!-- çµ±è¨ˆ -->
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-value" x-text="workflow.failCount || 0"></div>
        <div class="stat-label">å¤±æ•—é‡è©¦</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" x-text="workflow.rejectCount || 0"></div>
        <div class="stat-label">å¯©æŸ¥æ‹’çµ•</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" x-text="calcDuration(workflow.createdAt)"></div>
        <div class="stat-label">ç¶“éæ™‚é–“</div>
      </div>
    </div>

    <!-- ç„¡å·¥ä½œæµæç¤º -->
    <div class="empty-state" x-show="!workflow.workflowType">
      æ­¤ session å°šæœªå•Ÿå‹•å·¥ä½œæµã€‚ä½¿ç”¨ /ot:auto æˆ–æŒ‡å®š workflow é–‹å§‹ã€‚
    </div>
  </section>

  <!-- â•â•â• Timeline Tab â•â•â• -->
  <section x-show="tab === 'timeline'" x-cloak class="tab-content">

    <!-- åˆ†é¡ç¯©é¸ -->
    <div class="filter-bar">
      <button @click="timelineFilter = ''" :class="{ active: !timelineFilter }">å…¨éƒ¨</button>
      <template x-for="cat in categories" :key="cat.key">
        <button @click="timelineFilter = cat.key"
                :class="{ active: timelineFilter === cat.key }"
                x-text="cat.label"></button>
      </template>
    </div>

    <!-- äº‹ä»¶åˆ—è¡¨ -->
    <div class="timeline-list" x-ref="timelineList">
      <template x-for="(event, idx) in filteredEvents" :key="event.ts + '-' + event.type + '-' + idx">
        <div class="timeline-event" :class="'cat-' + event.category">
          <div class="event-time" x-text="formatTime(event.ts)"></div>
          <div class="event-label" x-text="event.label"></div>
          <div class="event-detail" x-text="formatEventDetail(event)"></div>
        </div>
      </template>

      <div class="empty-state" x-show="filteredEvents.length === 0">
        å°šç„¡äº‹ä»¶ç´€éŒ„
      </div>
    </div>
  </section>

  <script>
  // â”€â”€ Registryï¼ˆå¾ /api/registry å‹•æ…‹è¼‰å…¥ï¼Œæ¶ˆé™¤ç¡¬ç·¨ç¢¼é‡è¤‡ï¼‰ â”€â”€

  let stageRegistry = {};
  let workflowLabels = {};
  let agentColors = {};

  // å•Ÿå‹•æ™‚å¾ server è¼‰å…¥ registryï¼ˆSoT = scripts/lib/registry.jsï¼‰
  fetch('/api/registry').then(r => r.json()).then(data => {
    stageRegistry = data.stages || {};
    workflowLabels = Object.fromEntries(
      Object.entries(data.workflows || {}).map(([k, v]) => [k, v.label])
    );
    // å¾ stages åæŸ¥ agent â†’ color
    for (const [, v] of Object.entries(stageRegistry)) {
      if (v.agent && v.color) agentColors[v.agent] = v.color;
    }
  }).catch(() => {
    // fallbackï¼šAPI ä¸å¯ç”¨æ™‚ä½¿ç”¨ç©º registry
  });

  const eventCategories = [
    { key: 'workflow', label: 'å·¥ä½œæµ' },
    { key: 'stage',    label: 'éšæ®µ' },
    { key: 'agent',    label: 'ä»£ç†' },
    { key: 'loop',     label: 'å¾ªç’°' },
    { key: 'parallel', label: 'ä¸¦è¡Œ' },
    { key: 'handoff',  label: 'äº¤æ¥' },
    { key: 'error',    label: 'éŒ¯èª¤' },
    { key: 'session',  label: 'å·¥ä½œéšæ®µ' },
  ];

  // â”€â”€ Alpine.js ç‹€æ…‹ â”€â”€

  function sessionState(sessionId) {
    return {
      sessionId,
      connected: false,
      eventSource: null,
      tab: 'overview',
      workflow: {},
      events: [],
      timelineFilter: '',
      categories: eventCategories,
      durationTimer: null,

      // â”€â”€ è¨ˆç®—å±¬æ€§ â”€â”€

      get workflowLabel() {
        return workflowLabels[this.workflow.workflowType] || this.workflow.workflowType || 'ç„¡å·¥ä½œæµ';
      },
      get stageEntries() {
        return Object.entries(this.workflow.stages || {});
      },
      get activeAgentEntries() {
        return Object.entries(this.workflow.activeAgents || {});
      },
      get completedCount() {
        return this.stageEntries.filter(([, s]) => s.status === 'completed').length;
      },
      get totalCount() {
        return this.stageEntries.length;
      },
      get progressPercent() {
        return this.totalCount > 0 ? Math.round(this.completedCount / this.totalCount * 100) : 0;
      },
      get filteredEvents() {
        if (!this.timelineFilter) return this.events;
        return this.events.filter(e => e.category === this.timelineFilter);
      },

      // â”€â”€ ç”Ÿå‘½é€±æœŸ â”€â”€

      init() {
        this.fetchState();
        this.fetchTimeline();
        this.connectSSE();
        // æ¯ç§’æ›´æ–°æŒçºŒæ™‚é–“
        this.durationTimer = setInterval(() => this.$nextTick(() => {}), 10000);
      },

      destroy() {
        if (this.eventSource) this.eventSource.close();
        if (this.durationTimer) clearInterval(this.durationTimer);
      },

      // â”€â”€ è³‡æ–™è¼‰å…¥ â”€â”€

      async fetchState() {
        try {
          const r = await fetch('/api/sessions/' + this.sessionId);
          if (r.ok) this.workflow = await r.json();
        } catch {}
      },

      async fetchTimeline() {
        try {
          const r = await fetch('/api/sessions/' + this.sessionId + '/timeline');
          if (r.ok) this.events = await r.json();
        } catch {}
      },

      // â”€â”€ SSE é€£ç·š â”€â”€

      connectSSE() {
        if (this.eventSource) {
          this.eventSource.close();
        }

        const es = new EventSource('/sse/' + this.sessionId);

        es.addEventListener('connected', () => {
          this.connected = true;
        });

        es.addEventListener('workflow', (e) => {
          try {
            this.workflow = JSON.parse(e.data);
          } catch {}
        });

        es.addEventListener('timeline', (e) => {
          try {
            const event = JSON.parse(e.data);
            this.events.push(event);
            // è‡ªå‹•æ²å‹•åˆ°æœ€æ–°
            this.$nextTick(() => {
              const el = this.$refs.timelineList;
              if (el) el.scrollTop = el.scrollHeight;
            });
          } catch {}
        });

        es.addEventListener('heartbeat', () => {
          this.connected = true;
        });

        es.onerror = () => {
          this.connected = false;
          if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
          }
          setTimeout(() => this.connectSSE(), 3000);
        };

        this.eventSource = es;
      },

      // â”€â”€ è¼”åŠ©å‡½å¼ â”€â”€

      getStageEmoji(key) {
        const base = key.split(':')[0];
        return stageRegistry[base]?.emoji || 'â“';
      },

      getStageLabel(key) {
        const base = key.split(':')[0];
        const reg = stageRegistry[base];
        if (!reg) return key;
        // TEST stage é¡¯ç¤ºæ¨¡å¼
        if (base === 'TEST') {
          const stage = this.workflow.stages?.[key];
          if (stage?.mode === 'spec') return 'æ¸¬è©¦:è¦æ ¼';
          if (stage?.mode === 'verify') return 'æ¸¬è©¦:é©—è­‰';
        }
        return reg.label;
      },

      getAgentColor(name) {
        return agentColors[name] || 'var(--text-muted)';
      },

      calcDuration(iso) {
        if (!iso) return '-';
        const ms = Date.now() - new Date(iso).getTime();
        const m = Math.floor(ms / 60000);
        const s = Math.floor((ms % 60000) / 1000);
        if (m > 60) {
          const h = Math.floor(m / 60);
          return h + 'h ' + (m % 60) + 'm';
        }
        return m > 0 ? m + 'm ' + s + 's' : s + 's';
      },

      formatTime(iso) {
        if (!iso) return '';
        try {
          return new Date(iso).toLocaleTimeString('zh-TW', { hour12: false });
        } catch {
          return iso;
        }
      },

      formatEventDetail(event) {
        const parts = [];
        if (event.agent) parts.push(event.agent);
        if (event.stage) parts.push(event.stage);
        if (event.workflowType) parts.push(workflowLabels[event.workflowType] || event.workflowType);
        if (event.iteration !== undefined) parts.push('ç¬¬ ' + event.iteration + ' æ¬¡');
        if (event.progress) parts.push(event.progress);
        if (event.reason) parts.push(event.reason);
        if (event.result) parts.push(event.result);
        if (event.duration) parts.push(event.duration);
        return parts.join(' Â· ');
      },
    };
  }
  </script>

  <style>
  /* x-cloak éš±è—æœªåˆå§‹åŒ–çš„å…ƒç´  */
  [x-cloak] { display: none !important; }
  </style>

</body>
</html>
